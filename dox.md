# reclocks

## Classes

### `HashClock`

Implementation of the Reverse Entropy Clock.

#### Annotations

- uuid: bytes
- state: tuple[int, bytes]
- updater: HashClockUpdater

#### Methods

##### `__init__(uuid: bytes = <factory>, state: tuple[int, bytes] = None, updater: HashClockUpdater = None):`

##### `setup(max_time: int, seed_size: int = 16) -> HashClockUpdater | None:`

Set up the instance if it hasn't been setup yet and return the updater for the
clock. If it has been setup (i.e. has a uuid), return the updater if there is
one or None.

##### `read() -> int:`

Read the current state of the clock.

##### `can_be_updated() -> bool:`

Determines if the clock can possibly receive further updates.

##### `has_terminated() -> bool:`

Determines if the clock has provably terminated.

##### `update(state: tuple[int, bytes]) -> HashClock:`

Update the clock if the state verifies.

##### `verify() -> bool:`

Verifies the state.

##### `verify_timestamp(timestamp: tuple[int, bytes]) -> bool:`

Verifies the timestamp is valid for this clock.

##### `pack() -> bytes:`

Pack the clock down to bytes.

##### `@classmethod unpack(data: bytes) -> HashClock:`

Unpack a clock from bytes.

### `VectorHashClock`

VectorHashClock(uuid: 'bytes' = <factory>, node_ids: 'list[bytes]' = None,
clocks: 'dict[bytes, HashClock]' = <factory>)

#### Annotations

- uuid: bytes
- node_ids: list[bytes]
- clocks: dict[bytes, HashClock]

#### Methods

##### `__init__(uuid: bytes = <factory>, node_ids: list[bytes] = None, clocks: dict[bytes, HashClock] = <factory>):`

##### `setup(node_ids: list[bytes] = None, clock_uuids: dict[bytes, bytes] = {}) -> VectorHashClock:`

Set up the vector clock.

##### `@classmethod create(uuid: bytes, node_ids: list[bytes], clock_uuids: dict[bytes, bytes] = {}) -> VectorHashClock:`

Create a vector clock.

##### `read() -> dict:`

Read the clock as dict mapping node_id to tuple[int, bytes].

##### `advance(node_id: bytes, state: tuple[int, bytes]) -> dict:`

Create an update to advance the clock.

##### `update(state: dict) -> VectorHashClock:`

Update the clock using a dict mapping node_id to tuple[int, bytes].

##### `verify() -> bool:`

Verify that all underlying HashClocks are valid.

##### `verify_timestamp(timestamp: dict[bytes, bytes | tuple]) -> bool:`

Verify that the timestamp is valid.

##### `@staticmethod happens_before(ts1: dict, ts2: dict) -> bool:`

Determine if ts1 happens before ts2. As long as at least one node_id contained
in both timestamps has a higher value in ts1 and no node_id shared by both has a
higher value in ts2, ts1 happened-before ts2. Valid timestamps are generated by
the advance and read methods.

##### `@staticmethod are_incomparable(ts1: dict, ts2: dict) -> bool:`

Determine if ts1 and ts2 are incomparable. As long as the two timestamps share
one node_id in common, they are comparable.

##### `@staticmethod are_concurrent(ts1: dict, ts2: dict) -> bool:`

Determine if ts1 and ts2 are concurrent.

##### `pack() -> bytes:`

Pack the clock into bytes.

##### `@classmethod unpack(data: bytes) -> VectorHashClock:`

Unpack a clock from bytes.


